How would you design caching strategy using Redis?
practical, production-ready caching strategy using Redis, plus Java/Spring Boot code examples that you can directly use.

‚úÖ 1. When to Use Redis Caching

Redis fits well when your microservice needs:

Low-latency access for frequently accessed data

Reducing DB load

Distributed cache across replicas/pods

Consistency with TTL and eviction

Resilience with automatic reconnection

‚úÖ 2. Types of Caching Strategies

Depending on your use case:

A. Cache-aside (lazy loading) (Most common)

App checks cache ‚Üí if miss ‚Üí fetch from DB ‚Üí update cache.

Good for reads-heavy workloads.

B. Write-through

Whenever DB is written, also write to cache.

Strong consistency, higher write latency.

C. Write-behind

App writes to cache ‚Üí cache writes to DB asynchronously.

High performance but complex.

D. Read-through

Cache provider automatically loads from DB.

Used with Redis modules or custom abstraction.

üéØ Recommended Strategy: Cache-aside + TTL

Because it's simple + widely used + safe.

üèóÔ∏è 3. Redis Design Decisions
Key Structure
user:{id}
product:{id}
order:{id}

TTL Strategy

Hot data: TTL 5‚Äì30 minutes

Cold data / master data: 6‚Äì24 hours

Serialization

Use JSON or Kryo.
Spring Boot default: Jackson JSON.

Eviction policy

Use Redis default:

volatile-lru or allkeys-lru

üöÄ 4. Spring Boot Redis Config
pom.xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-data-redis</artifactId>
</dependency>

<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-cache</artifactId>
</dependency>

application.yml
spring:
  cache:
    type: redis

  redis:
    host: localhost
    port: 6379
    timeout: 2000
    lettuce:
      pool:
        max-active: 20
        max-idle: 10
        min-idle: 2

Redis Config Class
@Configuration
@EnableCaching
public class RedisConfig {

    @Bean
    public RedisTemplate<String, Object> redisTemplate(RedisConnectionFactory connectionFactory) {
        RedisTemplate<String, Object> template = new RedisTemplate<>();
        template.setConnectionFactory(connectionFactory);

        // Key serializer
        template.setKeySerializer(new StringRedisSerializer());

        // Value serializer using Jackson JSON
        template.setValueSerializer(new GenericJackson2JsonRedisSerializer());

        return template;
    }
}

üß† 5. Cache-aside Pattern ‚Äì Java Example
Service Layer With Caching (Spring Cache)
@Service
public class ProductService {

    @Autowired
    private ProductRepository productRepository;

    // Cache key: product::id
    @Cacheable(value = "product", key = "#id", unless = "#result == null")
    public Product getProductById(Long id) {
        System.out.println("Fetching from DB...");
        return productRepository.findById(id).orElse(null);
    }

    // Keep cache consistent on update
    @CachePut(value = "product", key = "#product.id")
    public Product updateProduct(Product product) {
        return productRepository.save(product);
    }

    // Evict when deleting
    @CacheEvict(value = "product", key = "#id")
    public void deleteProduct(Long id) {
        productRepository.deleteById(id);
    }
}

üß™ 6. Manual Redis Access (If You Need More Control)
@Service
public class UserCacheService {

    @Autowired
    RedisTemplate<String, Object> redisTemplate;

    private static final String KEY_PREFIX = "user:";

    public User getUser(Long id) {
        String key = KEY_PREFIX + id;

        // Check cache
        User cached = (User) redisTemplate.opsForValue().get(key);
        if (cached != null) {
            return cached;
        }

        // Fetch DB (mock)
        User user = loadUserFromDB(id);

        // Set TTL 10 minutes
        redisTemplate.opsForValue().set(key, user, 10, TimeUnit.MINUTES);

        return user;
    }
}

üìä 7. Redis Expiration Strategy
Good TTL rules:
Data Type	Suggested TTL
User sessions	15‚Äì60 min
Dashboard data	5‚Äì15 min
Price/inventory	1‚Äì5 min
Static master data	1‚Äì24 hrs
Frequently changing data	No TTL + manual eviction
üî• 8. Prevent Cache Stampede (Important!)
Use "Cache with mutex"
public Product getProduct(Long id) {
    String key = "product:" + id;

    Product cached = redisTemplate.opsForValue().get(key);
    if (cached != null) return cached;

    synchronized (("lock:" + id).intern()) {
        cached = redisTemplate.opsForValue().get(key);
        if (cached != null) return cached;

        Product p = loadFromDB(id);
        redisTemplate.opsForValue().set(key, p, 10, TimeUnit.MINUTES);
        return p;
    }
}

üéØ 9. Use Redis for Distributed Locking (Optional)

Use Redisson for:

Cache stampede protection

Distributed locks

Rate limiting

üß© 10. Final Architecture Recommendation
App ‚Üí Redis Cache ‚Üí DB
       ‚Üë     ‚Üë
       |     ‚îî‚îÄ‚îÄ TTL + eviction
       ‚îî‚îÄ‚îÄ‚îÄ‚îÄ Cacheable, CachePut, CacheEvict
